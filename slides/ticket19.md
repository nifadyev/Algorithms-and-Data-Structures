# Экзаменационный билет №19

## 1.Упорядоченные таблицы. Алгоритм быстрой сортировки.

**Сортированные (упорядоченные) таблицы** - таблицы, в которых записи располагаются в порядке возрастания (или убывания) ключей

Упорядоченность таблиц может быть организована только при возможности сравнения ключей (на множестве ключей задано отношение линейного порядка).

**Сортировка** - действия, связанные с размещением записей в порядке возрастания (или убывания) ключей

**Алгоритм сортировки** называют **устойчивым**, если он никогда не меняет относительный порядок в таблице двух записей с равными ключами

**Внутренняя сортировка** - Упорядочивание данных, при котором все значения располагаются в ОП

**Сортировка включением** 

Идея похода – вставка нового значения в упорядоченный набор данных.

**Алгоритм быстрой сортировки.**

Идея подхода (Hoare C.A.R.)– использование процедуры разделения упорядочиваемого набора на две части, в одной из которых располагаются значения, меньшие некоторого порогового (ведущего) элемента массива, в другой – соответственно большие значения. Подобный способ разделения может быть выполнен без привлечения дополнительной памяти.

```C++
// Разделение массива с использованием ведущего элемента
key = k[0]; // ведущий элемент
i1 = i2 = N - 1; // индексы левого (i1) и правого (i2) блоков
// цикл, пока разделяемые блоки не пересекутся
while (i1 <= i2) {
    // пока k[i1] не превышает ведущего элемента, переход вправо
    while ((i1 < N) && (k[i1] <= key))
        i1++;
    // пока k[i2] меньше ведущего элемента, переход влево
    while (k[i2] > key)
        i2--;
    //перестановка значений, которые приостановили разделение массива
    if (i1 < i2) {
        kt = k[i1];
        k[i1] = k[i2];
        k[i2] = kt;
    }
}
// установка ведущего элемента между блоками
k[0] = k[i2];
k[i2] = key;
i1 = i2; // индекс ведущего элемента
```

При наличии процедуры разделения алгоритм сортировки может быть определен рекурсивно – необходимо разбить упорядочиваемый набор на два блока с меньшими и большими значениями соответственно и затем последовательно отсортировать полученные блоки.

![](../pictures/ticket19-2.png)

**Оценка сложности:**

![](https://latex.codecogs.com/svg.latex?%5Clarge%20T_%7Bmin%7D%3DNlog_2N)

![](https://latex.codecogs.com/svg.latex?%5Clarge%20T_%7Bmax%7D%3DN%5E2)

![](https://latex.codecogs.com/svg.latex?%5Clarge%20T_%7Bcp%7D%3D%3F)

Вероятность выбора любого ключа в качестве ведущего элемента является одинаковой:

![](https://latex.codecogs.com/svg.latex?%5Clarge%20T%28N%29%20%5Cleq%20%5Calpha%20N%20&plus;%20%5Cfrac%7B1%7D%7BN%7D%20%5Csum%5E%7BN%3D1%7D_%7Bi%3D3%7D%5BT%28i-1%29&plus;T%28i&plus;1%29%5D%5D%3D%5Calpha%20N%20&plus;%20%5Cfrac%7B2%7D%7BN%7D%5Csum%5E%7BN%3D1%7D_%7Bi%3D0%7DT%28i%29)

Докажем по индукции, что

![](https://latex.codecogs.com/svg.latex?%5Clarge%20T%28N%29%20%5Cleq%20KNlnN%28K%3D2%5Calpha%20&plus;2%5Cbeta%2C%20%5Cbeta%3DT%280%29%3DT%281%29%29%20%5CRightarrow%20T%28N%29%20%5Cleq%20%5Calpha%20N%20&plus;%20%5Cfrac%7B2%7D%7BN%7D%28T%280%29&plus;T%281%29%29&plus;%5Cfrac%7B2%7D%7BN%7D%5Csum%5E%7BN%3D1%7D_%7Bi%3D2%7DKilni)

![](https://latex.codecogs.com/svg.latex?%5Clarge%20%5Cfrac%7B2%7D%7BN%7D%5Csum%5E%7BN%3D1%7D_%7Bi%3D2%7DKilni%20%5Cleq%20%5Cint_%7B2%7D%5E%7BN%7Dxlnxdx%20%5Cleq%20%5Cfrac%7BN%5E2lnN%7D%7B2%7D%20-%20%5Cfrac%7BN%5E2%7D%7B4%7D%20%5CRightarrow%20T%28N%29%20%5Cleq%20%5Calpha%20N%20&plus;%20%5Cfrac%7B4%5Cbeta%7D%7BN%7D&plus;%20%5Cfrac%7B2K%7D%7BN%7D%28%5Cfrac%7BN%5E2lnN%7D%7B2%7D-%5Cfrac%7BN%5E2%7D%7B4%7D%29%3D%20%5Calpha%20N&plus;%20%5Cfrac%7B4%5Cbeta%7D%7BN%7D&plus;KNlnN-%20%5Cfrac%7BKN%7D%7B2%7D)

![](https://latex.codecogs.com/svg.latex?%5Clarge%20%5Calpha%20N&plus;%20%5Cfrac%7B4%5Cbeta%7D%7BN%7D%20%5Cleq%20%5Cfrac%7BKN%7D%7B2%7D%28N%20%5Cleq%202%29%20%5CRightarrow%20T%28N%29%20%5Cleq%20KNlnN%20%5Cleq%20KNlog_2N)

Оценка сложности: ![](https://latex.codecogs.com/svg.latex?%5Clarge%20T_%7Bcp%7D%3D1.4%28N&plus;1%29log_2N)

## 2. Реализация структуры хранения нескольких стеков с использованием списков на языке высокого уровня

Звено списка представляются в виде объекта класса TLink

```C++
class TLink {
  public:
    int Value; 
    int Next;
  protected:
    TLink();
};
```

Образ памяти, выделенной для хранения стека, определяется в виде массива звеньев-объектов

```C++
TLink Mem[MemLimit];
```

Все свободные звенья объединяются в один список свободных звеньев. Звенья этого списка используются при необходимости свободной памяти, в этот список звенья должны возвращаться после освобождения.



![](../pictures/ticket19-3.png)

Структура хранения стека - линейный список (начало списка - вершина стека)

![](../pictures/ticket19-4.png)

Схемы работы со стеком и со списком свободных звеньев совпадают. Список свободных звеньев есть стек.
