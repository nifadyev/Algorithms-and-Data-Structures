# Экзаменационный билет № 6

## 1. Управление памятью путем перепаковки структур хранения на примере реализации N стеков на одном массиве.

**Перепаковка памяти (перепаковка)** - процедура динамического перераспределения памяти путем переписи части хранимых значений в другую область

Перепаковка **обеспечивает эффективное использование** одного ресурса ЭВМ (памяти) за счет другого ресурса (времени).


**Управление памятью** - выполнение функций анализа свободной памяти, планирование размещения структур, переписывание структур

**Система управления памятью** - комплекс программ, реализующих управление памятью

Необходимость перепаковки обуславливается принятым способом реализации отношений следования.

- N – количество стеков
- m – размер памяти

![](../pictures/ticket06-1.png)

Свойства:

- ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Li_0%20%3D%200) - условие неподвижности 1 стека
- ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Hi_k%20%3D%20Li_k%20-%201) - условие пустоты
- ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Hi_k%20%3C%20Li_%7Bk%20&plus;%201%7D) - условие неперекрытия
- ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Hi_k%20%3D%20Li_%7Bk%20&plus;%201%7D%20-%201) - условие переполнения
- Для выполнимости последних двух условий для всех стеков введем фиктивный стек N, для которого ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Li_N%20%3D%20m)
- Будем предполагать, что все стеки используются с одинаковой интенсивностью
  - значит память распределяется всем стекам поровну: ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Li_0%20%3D%200%2C%20Li_N%20%3D%20m%2C%20Li_k%20%3D%20Li_%7Bk-1%7D%20&plus;%20m%20/%20N%2C%201%20%3C%3D%20k%20%3C%3D%20N)

Выполняется при попытке вставки нового значения в стек s, у которого отсутствует свободная память: ![](https://latex.codecogs.com/svg.latex?%5Clarge%20F%20%3D%20%5CSigma%20%28Hi_k-Li_%7Bk-1%7D-1%29%2C%201%20%3C%3D%20k%20%3C%3D%20N)

- F = 0 – свободной памяти нет
- F = 1 – свободен 1 элемент памяти и его следует отдать стеку s
- F > 1 – необходимо перераспределить свободную память.

Для гарантированного выделения свободной памяти стеку s при наличии только одного свободного элемента памяти (случай 2), выполним:

- ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Hi_s%3DHi_s&plus;1) – перед началом процедуры оценки свободной памяти
- ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Hi_s%3DHi_s-1) – после завершения перепаковки. Снова предположим, что все стеки используются с одинаковой интенсивностью - значит свободная память должна распределиться всем стекам поровну: 
  - ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Li%27_0%3D%20Li_0)
  - ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Li%27_N%3D%20Li_N)
  - ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Li%27_k%3DLi%27_%7Bk-1%7D&plus;%20%28Hi_%7Bk-1%7D-Li_%7Bk-1%7D&plus;1%29%20&plus;%20F%20/%20N%2C%201%20%3C%3D%20k%20%3C%3D%20N)
- На равномерности распределения памяти может сказаться целочисленность операции деления

![](../pictures/ticket06-2.png)

![](../pictures/ticket06-3.png)

![](../pictures/ticket06-4.png)

## 2. Структуры хранения для матриц специального вида

### Ленточные матрицы

Для хранения элементов можно выделить непрерывный вектор памяти размера 3*n-2

Адрес ![](https://latex.codecogs.com/svg.latex?%5Clarge%20%28a_%7Bij%7D%29%20%3D%20%5Calpha%20&plus;%203*%28i-1%29%20&plus;%20%28j-i%29)

![](https://latex.codecogs.com/svg.latex?%5Clarge%20%5Cbegin%7Bpmatrix%7D%20a_%7B11%7D%20%26%20a_%7B12%7D%5C%5C%20a_%7B21%7D%20%26%20a_%7B22%7D%20%26%20a_%7B22%7D%5C%5C%20%26%20a_%7B32%7D%20%26%20a_%7B33%7D%20%26%20a_%7B34%7D%5C%5C%20%26%20%26%20a_%7B43%7D%20%26%20a_%7B44%7D%20%26%20a_%7B45%7D%5C%5C%20%26%20%26%20%26%20a_%7B54%7D%20%26%20a_%7B55%7D%5C%5C%20%5Cend%7Bpmatrix%7D)

### Треугольные матрицы

![](https://latex.codecogs.com/svg.latex?%5Clarge%20%5Cbegin%7Bpmatrix%7D%20a_%7B11%7D%20%26%20a_%7B12%7D%20%26%20a_%7B13%7D%20%26%20%5Cdots%20%26%20a_%7B1n%7D%5C%5C%20%26%20a_%7B22%7D%20%26%20a_%7B23%7D%20%26%20%5Cdots%20%26%20a_%7B2n%7D%5C%5C%20%26%20%26%20a_%7B33%7D%20%26%20%5Cdots%20%26%20a_%7B3n%7D%5C%5C%20%26%20%26%20%26%20%5Cdots%5C%5C%20%26%20%26%20%26%20%26%20a_%7Bnn%7D%20%5Cend%7Bpmatrix%7D)

Подход 1:

![](../pictures/ticket06-8.png)

- Матрицы подобного вида можно представить как матрицы общего вида и использовать для хранения двухиндексные массивы. - Используется память ![](https://latex.codecogs.com/svg.latex?%5Clarge%20V_%7Bused%7D) = n2, необходимая память ![](https://latex.codecogs.com/svg.latex?%5Clarge%20V_%7Bneeded%7D) = n * (n+1) / 2
- Эффективность использования памяти Emem = 0.5

Подход 2:

![](../pictures/ticket06-9.png)

- Исключение хранения элементов ниже главной диагонали (построчная запись в массив)
- Адрес ![](https://latex.codecogs.com/svg.latex?%5Clarge%20%28a_%7Bij%7D%29%20%3D%20%5Calpha%20&plus;%20i*n-i*%28i-1%29/2%20&plus;%20%28j-i%29%2C%200%20%3C%3D%20i%2Cj%20%3C%3D%20n-1)
- Ускорение доступа – использование вектора указателей на первые элементы каждой строки. Адрес ![](https://latex.codecogs.com/svg.latex?%5Clarge%20%28a_%7Bij%7D%29%20%3D%20pRow%5Bi%5D%20&plus;%20%28j-i%29%2C0%20%3C%3D%20i%2Cj%20%3C%3D%20n-1)

Подход 3:

![](../pictures/ticket06-10.png)

- Представление матрицы в виде набора векторов

Подход 4:

![](../pictures/ticket06-11.png)

- Матрица как вектор векторных элементов (шаблоны)
