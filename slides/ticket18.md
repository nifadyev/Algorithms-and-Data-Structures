# Экзаменационный билет №18

## 1.Организация доступа по имени

Структура памяти

- Для чтения или записи значения необходимо указать адрес элемента памяти, для человека более привычный способ указания данных - имя.

Структура данных

- Понятие таблицы
- Пусть `К` - множество имен
- `А` - множество адресов
- Отношение “иметь имя” есть функция `f:К->А`

**Возможные задания `f`(возможный способ - табличное задание функции):**

1. Таблица-последовательность строк(записей)
2. Запись может состоять из нескольких полей
3. Одно из полей должно задавать имя записи(ключ),остальные поля образуют тело записи.

**Операции под таблицей:**

- поиск записей по ключу
- вставка новой записи
- удаление записи

**Таблица** - динамическая структура данных.

**Базисное множество** - семейство линейных структур из записей, **базисное отношение** включения определяется операциями вставки и удаления записей.

**Варианты расширения понятия таблицы:**

- наличие нескольких ключей
- доступ по телу записей
- сложные запросы для поиска
- дополнительные операции

**Принцип реализации таблиц:**

- операции над таблицей не определяются(не предполагают) тот или иной порядок размещения записей в памяти ЭВМ
- реализация таблицы должна способствовать быстрому выполнению операций(в основном доступа)
    - свобода в размещении записей позволяет разработать несколько способов организации таблиц

Введение различных способов предполагает явное или неявное существование разных типов ситуаций при использовании таблиц.

**По организации способа доступа таблицы делятся на следующие категории:**

- просматриваемые таблицы
- упорядоченные таблицы
- таблицы прямого доступа
- перемешанные(хэш) таблицы

### Просматриваемые таблицы

Порядок расположения элементов никак не связан со значениями ключей. Поэтому **поиск** элемента по ключу **осуществляется обычным просмотром всех элементов** таблицы, начиная с первого и до искомого

- если он есть в таблице
  - тогда поиск заканчивается успешно
- или до конца таблицы
  - тогда поиск заканчивается неуспешно

| Ключ | Информация |
| ---- | :--------: |
| 08   | ...        |
| 33   | ...        |
| 47   | ...        |
| 25   | ...        |
| 18   | ...        |

- При отображении просматриваемой таблицы списком не играет роли, какую – статическую или динамическую – таблицу использовать
- Структура элемента таблицы (списка) будет одинакова
- При включении в таблицу новый элемент может быть размещен в любом месте таблицы (списка)
- Если некоторый элемент удаляется из списка, действия, выполняемые при этом, могут быть разными в зависимости от того, какой элемент удаляется

![](../pictures/ticket17-1.png)

- Если удаляется первый элемент списка, в этом случае должен быть модифицирован указатель на начало списка (таблицы)
- Если же удаляется некоторый элемент из середины списка, тогда модифицируется поле указателя предыдущего элемента

**Таким образом, при удалении элемента надо:**

- иметь доступ к предшествующему элементу списка
- различать вид предшествующего элемента.

Поскольку операция поиска возвращает искомый элемент и не сообщает о месте его размещения в списке, при реализации операции удаления элемента из списка приходится либо

- (a) повторять поиск элемента
- либо (b) следует несколько изменить реализацию операции поиска.
  - Способ (b) удобно реализуется средствами языка С/С++

Алгоритм удаления элемента из просматриваемой таблицы-списка по варианту a) приведен на рисунке.

- В приведенном алгоритме отдельно рассматриваются удаление первого и промежуточного элементов таблицы, поскольку это приводит к необходимости модифицировать разные структуры
  - указатель на начало таблицы при удалении первого элемента и поле указателя в элементе списка при удалении промежуточного элемента
- В результате в блоке C2 сравниваются ключи первого элемента таблицы и удаляемого элемента и, при их совпадении, в блоке D2 переопределяется указатель на начало таблицы.

![](../pictures/ticket17-2.png)

- Если удаляется не первый элемент, осуществляется в цикле (блоки C3, D3, E3) поиск удаляемого элемента
- При этом используются два указателя – на текущий (cur) и на предыдущий (prev) элементы таблицы
- При совпадении ключей переопределяется поле ссылки в предыдущем элементе (на который указывает prev), в результате чего элемент удаляется из таблицы-списка

**Текст программы, соответствующий приведенному алгоритму**

```C++
struct Item
{
    int key;
    Type info;
    Item *next;
};
Item *ptab; /*указатель на начало таблицы */
int del1(int k)
{
    Item *cur, *prev;
    cur = ptab;
/*проверяем, есть ли в таблице элементы */
    if(!cur)
        return -1; /*таблица пуста – отказ */
/*возможно, требуется удалить первый элемент таблицы */
    if(cur->key == k)
    {
    /* удаляем первый элемент */
        ptab = cur->next;
        delInfo(cur->info);
        delete cur;
        return 0;
    }
/* ищем удаляемый элемент среди других элементов таблицы */
    while(cur->next)
    {
    /* есть другие элементы */
        prev = cur;
        cur = cur->next;
        if(cur->key == k)
        {
        /* нашли элемент, который надо удалить */
            prev->next = cur->next;
            delInfo(cur->info);
            delete cur;
            return 0;
        }
    }
/* естественный выход из цикла – в таблице нет элемента с ключом k */
    return -1;
}
```

## 2. Роль гипотез о росте структур при разработке систем управления памятью путем перепаковки

Формирование гипотез происходит в результате теоретического анализа модели решаемой задачи или может быть выполнено на основе статистических данных, получаемых в ходе вычислительных экспериментов с проектируемой программной системой.

**Гипотеза 1**: Стеки используются с одинаковой интенсивностью, память разделяется между стеками поровну.

**Гипотеза 2**: Интенсивность использования стеков различается.

- Конструктивное предположение о характере такой неравномерности может состоять в гипотезе сохранения локальных тенденций роста стеков
  - в каждый момент времени использование стеков на последующих шагах вычислений характеризуется точно таким же поведением, что и на предшествующих этапах обработки данных.
- Сохранение локальных тенденций роста:

  - показатель роста стека ![](https://latex.codecogs.com/svg.latex?%5Clarge%20%5Cdelta%20%3D%20max%280%2C%20DataCount%5E%60_i%20-%20DataCount_i%29)
  - суммарный показатель роста ![](https://latex.codecogs.com/svg.latex?%5Clarge%20%5CDelta%20%3D%20%5Csum%5Cdelta_i%2C%200%20%3C%20i%20%3C%20N)
  - правило распределение памяти для стеков в соответствии с их показателями роста ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Li%27_k%20%3D%20Li%27_%7Bk-1%7D%20&plus;%20%28Hi_%7Bk-1%7D%20-%20Li_%7Bk-1%7D%20&plus;%201%29%20&plus;%20F%20*%20%28%5Cdelta_i%20/%20%5CDelta%29%2C%201%20%3C%20k%20%3C%20N)

**Гипотеза 3**: Использование вероятностных предположений о поведении стеков.

- Пусть есть ![](https://latex.codecogs.com/svg.latex?%5Clarge%20%5Ctheta%2C%200%20%3C%20%5Ctheta%20%3C%201)
- вероятность выполнимости гипотезы сохранения локальных тенденций роста. Тогда ![](https://latex.codecogs.com/svg.latex?%5Clarge%20Li%27_k%20%3D%20Li%27_%7Bk-1%7D%20&plus;%20%28Hi_%7Bk-1%7D%20-%20Li_%7Bk-1%7D%20&plus;%201%29%20&plus;%20%281-%5Ctheta%29%20*%20%28F%20/%20N%29%20&plus;%20%5Ctheta%20*%20F%20*%20%28%5Cdelta_i%20/%20%5CDelta%29%2C%201%20%3C%20k%20%3C%20N.)
