# Экзаменационный билет №21

## 1.Плексы как представление рисунков, состоящих из точек и соединяющих их отрезков

В качестве базовых объектов рассматриваются основные геометрические фигуры – точку, окружность, прямоугольник и т.д.

**Информационное описание объектов** – параметры фигуры (координаты, размер, радиус и др.). В общем случае, описание фигуры включает значение координат некоторой опорной точки.

**Операции обработки** геометрических объектов включают методы для задания и изменения параметров; расширим набор операций процедурами визуализации и скрытия фигур.

Схема иерархии классов для реализации геометрических объектов:

![](../pictures/ticket21-1.png)

Для обеспечения возможности динамической визуализации геометрических объектов введем тип данных, значения которого вычисляются в соответствии с задаваемым формульным выражением.

**Составной объект** – набор геометрических объектов (как базовых, так и составных), рассматриваемых при выполнении операций обработки как единый объект.

**Геометрический объект** может быть сконструирован с использованием уже существующих объектов (например, ломаная может быть определена через набор конечных точек составляющих отрезков).

**Геометрический объект** может быть образован при помощи сборки существующих объектов – рассмотрим данный способ построения новых объектов на примере рисунков (чертежей), образованных только из объектов двух базовых типов: точек и линий

![](../pictures/ticket21-2.png)

![](../pictures/ticket21-3.png)

- Узел структуры хранения представляет линию чертежа.
- Указатель на начальную точку линии может также указывать на линию, т.е. конечная точка предыдущей линии является начальной точкой следующей линии.
- **Плекс** - структура хранения данного вида (содержит элементы разного типа).
    - Является общей структурой хранения сетевых моделей данных.
- Повторяющая точка на чертеже должна быть представлена одним и тем же объектом (не следует допускать множественности представления одного и того же значения).
- Разработанная структура хранения позволяет обеспечить представление чертежей, которые можно нарисовать без отрыва карандаша от бумаги.

![](../pictures/ticket21-4.png)

## 2. Сравнение непрерывной и списковой структур хранения

<!-- ![](../pictures/ticket21-5.png) -->

- Для хранения элементов базисного множества выделяется вектор памяти размера, достаточного для хранения максимально возможного количества значения в стеке.
- Хранение значений в памяти осуществляется последовательно от младшего элемента вектора к старшему.
- Для запоминания количества хранимых в стеке значений используется индекс последнего занятого элемента в векторе.

![](../pictures/ticket21-5.png)

Операции:

- IsEmpty - проверка на пустоту
- IsFull - проверка на полноту
- Put - добавление значения
- Get - извлечение значения

<!-- ![](../pictures/ticket21-7.png) -->

Класс TStack обеспечивает реалзацию динаммической структуры стек.

**Управление памятью** - хранение значений осуществляется в векторе пямяти от младших элементов к старшим. Индекс последнего занятого элемента в векторе пямяти фиксируется в переменной ![](https://latex.codecogs.com/svg.latex?%5Clarge%20H_i).

Методы:

- GetNextIndex - метод для получения следующего значения индекса (скрытие способа реализации отношения следования)
- Put - операция вставки нового значения в структуру
- Get - операция выборки очередного значения из структуры

<!-- ![](../pictures/ticket21-8.png) -->

```C++
#define MemSize 25 // размер памяти для стека
class TStack
{
 protected:
    int Mem[MemSize]; // память для СД
    int Top; // индекс последней занятой ячейки
 public:
    TStack () { Top = -1; }
    int IsEmpty (void) const { Top == -1; }
    int IsFull (void) const { Top == MemSize-1;}
    void Put ( const int Val ) { Mem[++Top] = val; }
    TData Get (void) { return Mem[Top--]; }
};
```

### Очередь

Очередь (вставка в конец очереди, исключение из начала - FIFO - first in, first out)

Вставка значений происходит в начало очереди, исключение - с конца очереди => для индикации начала и конца очереди требуется 2 индекса.

В ходе вычислений может возникнуть ситуация ![](https://latex.codecogs.com/svg.latex?%5Clarge%20L_i) = ![](https://latex.codecogs.com/svg.latex?%5Clarge%20H_i) = n - 1. Тогда вставка нового значения невозможна, а ![](https://latex.codecogs.com/svg.latex?%5Clarge%20E_{mem) = 0.

![](../pictures/ticket21-6.png)

### Способы достижения полного использования памяти

![](../pictures/ticket21-7.png)

Сдвиг значений очереди после выборки очередного значения (т.е. обеспечение ![](https://latex.codecogs.com/svg.latex?%5Clarge%20L_i)=0) – возрастание накладных расходов, использование левого участка свободной области при достижении ![](https://latex.codecogs.com/svg.latex?%5Clarge%20H_i)=n-1 (т.е. при отсутствии свободной памяти справа).

**Циклический или кольцевой буфер** - структура хранения, получаемая из вектора расширением отношения следования парой ![](https://latex.codecogs.com/svg.latex?%5Clarge%20p%28a_n%2Ca_1%29). Реализация кольцевого буфера логически может быть обеспечена переходом индексов ![](https://latex.codecogs.com/svg.latex?%5Clarge%20L_i) и ![](https://latex.codecogs.com/svg.latex?%5Clarge%20H_i) при достижении граничного значения `MemSize-1` на индекс первого элемента вектора памяти.
