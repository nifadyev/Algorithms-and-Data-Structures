# Экзаменационный билет №14

## 1.Алгоритм обхода иерархического списка (итератор)

Печать текста: схема обхода

- текст текущей строки
- текст подуровня
- текст следующего раздела текста того же уровня (top-down-next).

```C++
while (1)
{
   if (pLink != NULL)
   {
       cout << pLink->Str; // обработка звена
       St.push(pLink); // запись в стек
       pLink = pLink->pDown; // переход на подуровень
   }
   else if (St.empty())
       break;
   else
   {
       pLink = St.top();
       St.pop(); // выборка из стека
       pLink = pLink->pNext; // переход по тому же уровню
   }
}
```

**Ввод текста из файла**: уровень текста в файле можно выделить строками специального вида (например, скобками '{' и '}')

Общая схема алгоритма:

```
повторить:
ввод строки
ЕСЛИ '}' ТО Завершить
ЕСЛИ '{' ТО Выполнить рекурсивно Ввод_текста
Добавить строку на том же уровне
```

Реализация итератор:

- схема обхода TDN нерекурсивный вариант
- корневые звенья необработанных разделов текста запоминаются в стеке
- текущая строка в стеке не хранится(кроме звена всего текста)

```C++
int TText::Reset(void) // Установка на корневое звено текста
{
   pCurrent = pFirst;
   if (pCurrent != nullptr)
   {
       St.push(pCurrent);
       if (pCurrent->pNext != nullptr)
           St.push(pCurrent->pNext);
       if (pCurrent->pDown != nullptr)
           St.push(pCurrent->pDown);
   }
}

bool TText::IsTextEnded(void) const // Стек пуст?
{
   return St.empty();
}

bool TText::GoNext(void) // Переход к следующему звену текста
{
   if (!IsTextEnded())
   {
       pCurrent = St.top();
       St.pop();
       if (pCurrent != pFirst)
       {
           if (pCurrent->pNext != nullptr)
               St.push(pCurrent->pNext);
           if (pCurrent->pDown != nullptr)
               St.push(pCurrent->pDown);
       }

   }
   return IsTextEnded();
}
```

## 2. Пример использования стеков: преобразование арифметических выражений в польскую форму записи

Формат записи выражения:

- Выражение синтаксически правильно (без ошибок)
- Допускаются только однобуквенные идентификаторы для операндов
- В записи выражения нет пробелов
- Выражение заканчивается знаком `'='`: `A+(B-C)*D-F/(G+H)=`

Алгоритм:

1.  Для операций вводится приоритет:`'*' '/' (3), '+' '-' (2), '(' (1), '=' (0)`
2.  Для хранения данных используется 2 стека (1 – для результата, 2 – для операций)
3.  Исходное выражение просматривается слева направо
4.  Операнды по мере их появления помещаются в стек 1
5.  Символы операций и левые скобки помещаются в стек 2
6.  При появлении правой скобки последовательно изымаются элементы из стека 2 и переносятся в стек 1. Данные действия продолжаются либо до опустошения стека 2 либо до попадания в стеке 2 на левую скобку
7.  Если текущая операция, выделенная при обходе выражения, имеет меньший (более низкий) приоритет, чем операция на вершине стека 2, то такие операции из стека 2 переписываются в стек 1

Пусть выражение имеет вид: A + (B - C) * D - F / (G + H)=

![](../pictures/ticket14-1.png)
